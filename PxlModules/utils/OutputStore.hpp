#ifndef _OUTPUTSTORE_H_#define _OUTPUTSTORE_H_#include <unordered_map>#include <TTree.h>#include <TFile.h>#include <TObject.h>#include <TBranch.h>#include <string>#include <iostream>#include <pxl/core.hh>class Variable{    public:        virtual ~Variable()        {        }                virtual void* getAddress() = 0;        virtual unsigned int getSize() const = 0;                template<class TYPE>        Variable* operator=(const TYPE& value);        template<class TYPE> TYPE get() const;};template<class TYPE>class VariableTmpl:    public Variable{    private:        TYPE* _value;    public:        VariableTmpl(const TYPE& value):            _value(new TYPE(value))        {        }                virtual void* getAddress()        {            return _value;        }                virtual unsigned int getSize() const        {            return sizeof(TYPE);        }                void setValue(const TYPE& value)        {            *_value=value;        }                void getValue()        {            return *_value;        }                ~VariableTmpl()        {            delete _value;        }};template<class TYPE>Variable* Variable::operator=(const TYPE& value){    VariableTmpl<TYPE>* var = dynamic_cast<VariableTmpl<TYPE>*>(this);    if (var)    {        var->setValue(value);        return this;    }    throw "Error - variable and value type do not match";    return this;}template<class TYPE> TYPE Variable::get() const{    VariableTmpl<TYPE>* var = dynamic_cast<VariableTmpl<TYPE>*>(this);    if (var)    {        return var->getValue();    }    throw "Error - variable and return type do not match";    return 0;}class Tree{    private:        static const int INVALID;        unsigned int _count;        std::unordered_map<std::string,Variable*> _variables;        TTree* _tree;        TFile* _file;        pxl::Logger _logger;    public:        Tree(TFile* file, std::string name);                template<class TYPE>        void storeVariable(std::string name, const TYPE& value)        {            std::unordered_map<std::string,Variable*>::iterator elem = _variables.find(name.c_str());            if (elem==_variables.end()) {                VariableTmpl<TYPE>* var = bookVariable<TYPE>(name);                var->setValue(value);            } else {                (*elem->second)=value;            }        }                template<class TYPE>        VariableTmpl<TYPE>* bookVariable(std::string name, const TYPE& defaultValue=Tree::INVALID)        {            VariableTmpl<TYPE>* var = new VariableTmpl<TYPE>(defaultValue);            _variables[name]=var;            TBranch* branch = _tree->Branch(name.c_str(),(TYPE*)var->getAddress());            _logger(pxl::LOG_LEVEL_INFO ,"fill new variable '",name,"' int tree '",_tree->GetName(),"' with ",_count," empty entries");            for (unsigned int cnt=0;cnt<_count; ++cnt)            {                branch->Fill();            }            return var;        }                void fill();        void write();};class OutputStore{    private:        TFile* _file;        std::unordered_map<std::string,Tree*> _treeMap;        pxl::Logger _logger;    public:        OutputStore(std::string filename);        Tree* getTree(std::string treeName);        void close();};#endif